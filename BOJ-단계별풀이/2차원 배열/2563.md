## BOJ 2563 색종이

|🔗|https://www.acmicpc.net/problem/2563|
|---|---|
|풀이 언어|Swift|
|풀이 날짜|23.02.18|

</br>


##  풀이

도화지를 각 행과 열로 이루어진 2차원 Bool 배열이라 가정하고 false로 초기화해 준다.
입력받은 x좌표부터 x좌표+10 범위, y좌표부터 y좌표+10까지의 범위만큼을 true로 바꾼다.
반복문과 count를 사용하여 색칠된 수를 출력한다.


```Swift
let T: Int = Int(readLine()!)!
var paperArea: [[Bool]] = Array(repeating: Array(repeating: false, count: 101), count: 101)
var count: Int = 0

for _ in 0..<T {
    let nums: [Int] = readLine()!.split(separator: " ").map { Int($0)! }

    for i in nums[0]..<nums[0]+10 {
        for j in nums[1]..<nums[1]+10 {
            paperArea[i][j] = true
        }
    }
}
for i in 0..<101 {
    for j in 0..<101 {
        if paperArea[i][j] {
            count += 1
        }
    }
}
print(count)
```

</br>

## 더 고민해 보기

 `flatMap`을 사용하여 2차원 배열을 1차원 배열로 합쳐 준 뒤 `filter`을 사용하여 true 값만 골라내었다.

```Swift
let T: Int = Int(readLine()!)!
var paperArea: [[Bool]] = Array(repeating: Array(repeating: false, count: 101), count: 101)
var count: Int = 0

for _ in 0..<T {
    let nums: [Int] = readLine()!.split(separator: " ").map { Int($0)! }
    
    for i in nums[0]..<nums[0]+10 {
        for j in nums[1]..<nums[1]+10 {
            paperArea[i][j] = true
        }
    }
}

print(paperArea.flatMap { $0 }.filter { $0 }.count)
```

</br>

## 기록하기

### 1. flatMap(_:)

중첩된 배열을 flatten한 배열로 만든다.

```Swift
let numbers = [1, 2, 3, 4]

let mapped = numbers.map { Array(repeating: $0, count: $0) }
// [[1], [2, 2], [3, 3, 3], [4, 4, 4, 4]]

let flatMapped = numbers.flatMap { Array(repeating: $0, count: $0) }
// [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]
```
