## BOJ 1978 소수 찾기

|🔗|https://www.acmicpc.net/problem/1978|
|---|---|
|풀이 언어|Swift|
|풀이 날짜|23.02.12|

</br>


##  풀이

1은 소수가 아니다. 또한 소수는 1과 자기 자신만을 약수로 가진다. 이와 같은 특징을 활용하여 입력받은 숫자들로부터 1일 때는 따로 처리를 해 주고, 2부터 자기 자신의 숫자가 되기 전까지 순회하여
나눠지는 수가 있을 때는 소수가 아님을 구현한다. 마지막에 입력받은 수의 개수에서 `count`를 빼 주었다.

```Swift
let N: Int = Int(readLine()!)!
let nums: [Int] = readLine()!.split(separator: " ").map { Int($0)! }
var count: Int = 0

for num in nums {
    if num == 1 { // 1은 소수가 아님.
        count += 1
        continue
    }
    for i in 2 ..< num {
        if num % i == 0 { // 소수가 아님.
            count += 1
            break
        }
    }
}

print(nums.count - count)
```

</br>

## 더 고민해 보기

### 에라토스테네스의 체

소수 판별 알고리즘인 에라토스테네스의 체 활용해 보기. 
1. 2부터 소수를 구하고자 하는 구간까지의 모든 수를 배열로 만든다. 1978번은 1000까지.
2. 2의 배수인 요소를 모두 0으로, 3의 배수인 요소를 모두 0으로... 이 방식을 1000까지 반복한다.
3. 0이 되지 않은 수는 소수이므로 이 중 포함된 입력받은 수를 체크한다.

```Swift
let N: Int = Int(readLine()!)!
let nums: [Int] = readLine()!.split(separator: " ").map { Int($0)! }
var a: [Int] = Array(repeating: 0, count: 1001)
var count: Int = 0

for i in 2...1000 {
    a[i] = i
}

for i in 2...1000 {
    if a[i] == 0 {
        continue
    }

    for j in stride(from: i + i, through: 1000, by: i) {
        a[j] = 0
    }
}

for num in nums {
    if a.contains(num) {
        count += 1
    }
}

print(count)
```

</br>

## 기록하기

### stride(from:through:by:)

시작 값부터 끝값까지 지정된 보폭만큼 진행

```Swift
func stride<T>(
    from start: T,
    through end: T,
    by stride: T.Stride
) -> StrideThrough<T> where T : Strideable
```

- `start`: 시작값
- `end`: 끝값
- `by`: 각 반복마다 진행될 보폭

```Swift
for i in stride(from: 1, through: 10, by: 3) {
    print(i, terminator: " ")
}
// 결과: 1 4 7 10
```
