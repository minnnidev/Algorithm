## BOJ 4948 베르트랑 공준

|🔗|https://www.acmicpc.net/problem/4948|
|---|---|
|풀이 언어|Swift|
|풀이 날짜|22.02.14|

</br>


##  풀이

1978, 1929와 같이 에라토스테네스의 체 알고리즘을 활용한다. </br>

1. 첫 번째 풀이에서는 매 입력마다 `2n+1` 만큼의 배열 중 소수만을 선별한다. 최종으로 `n+1 ~ 2n` 배열 중 포함된 소수만 count한다. 

```Swift
while (true) {
    let n: Int = Int(readLine()!)!

    if n == 0 { break }

    var primeNums: [Int] = Array(repeating: 0, count: 2*n+1)
    var count: Int = 0

    for i in 2...(2*n) {
        primeNums[i] = i
    }
    for i in 2...(2*n) {
        if primeNums[i] == 0 { continue }
        for j in stride(from: i+i, through: 2*n, by: i) {
            primeNums[j] = 0
        }
    }
    for i in (n+1)...(2*n) {
        if primeNums[i] != 0 {
            count += 1
        }
    }
    print(count)
}
```

</br>

2. 제한이 `1 ≤ n ≤ 123,456` 로 되어 있고, 2n까지의 범위를 구해야 하므로, `0 ~ 246912` 만큼의 배열을 먼저 만들고 소수를 판별하는 풀이를 해 줬더니 훨씬 빠른 시간 내에 풀이할 수 있었다.

```Swift
var primeNums: [Int] = Array(repeating: 0, count: 246913)

for i in 2...246912 {
    primeNums[i] = i
}

for i in 2...246192 {
    if primeNums[i] == 0 { continue }
    for j in stride(from: i+i, through: 246912, by: i) {
        primeNums[j] = 0
    }
}

while (true) {
    let n: Int = Int(readLine()!)!
    var count: Int = 0

    if n == 0 { break }

    for i in (n+1)...(2*n) {
        if primeNums[i] != 0 { count += 1 }
    }
    print(count)
}
```

