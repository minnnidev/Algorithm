## BOJ 2675 문자열 반복

|🔗|https://www.acmicpc.net/problem/9020|
|---|---|
|풀이 언어|Swift|
|풀이 날짜|22.02.15|

</br>


##  풀이

이전 문제와 같이 에라토스테네스의 체 알고리즘 풀이를 사용한다. </br>
문제의 제한을 보면 `4 ≤ n ≤ 10,000`으로 범위가 정해져 있으므로, 그에 맞춰 0~10000까지의 배열을 만들고, 소수가 아닐 땐 0으로 바꿔 준다. 합이 되었을 때 두 소수의 차이가 가장 작은 경우를 출력하기 위해 
n/2 지점의 인덱스부터 시작하여 한쪽은 줄여가고, 한쪽은 늘려가며 합이 되는 경우를 찾는다.


```Swift
var primeNums: [Int] = Array(repeating: 0, count: 10001)

for i in 2...10000 {
    primeNums[i] = i
}
for i in 2...10000 {
    if primeNums[i] == 0 { continue }
    for j in stride(from: i+i, through: 10000, by: i) {
        primeNums[j] = 0
    }
}

let T: Int = Int(readLine()!)!

for _ in 0..<T {
    let n: Int = Int(readLine()!)!
    var a: Int = n/2
    var b: Int = n/2

    while (true) {
        if (primeNums[a] + primeNums[b]) == n {
            print(primeNums[a], primeNums[b])
            break
        } else {
            a -= 1
            b += 1
        }
    }
}

```
