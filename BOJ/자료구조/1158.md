## BOJ 1158 요세푸스 문제

|🔗|https://www.acmicpc.net/problem/1158|
|---|---|
|풀이 언어|Swift|
|풀이 날짜|23.04.04|

</br>


##  풀이

이전 단계의 인덱스를 저장하는 `index` 변수를 선언한다. 

```
1...N까지를 저장하는 배열 nums 선언
nums 배열이 빈 배열이 될 때까지 while문을 사용하여 순회
while문 안에서 index는 K-1만큼 늘어난다. 각 순회에의 K번째 숫자는 삭제되기 때문.
이러한 과정에서 index가 배열의 범위를 넘어선다면 넘어서지 않을 때까지 배열의 개수만큼 빼준다.
해당 index에 해당하는 배열의 요소를 삭제한 뒤 result 배열에 넣는다.
마지막으로 result 배열 출력하기
```

```Swift
let line: [Int] = readLine()!.split(separator: " ").map { Int($0)! }
var nums: [Int] = Array<Int>(1...line[0])
var result: [Int] = []
var index: Int = 0

while !(nums.isEmpty) {
    index += line[1] - 1
    while (index > nums.count - 1) { index -= nums.count }
    result.append(nums.remove(at: index))
}

print("<", result.map { String($0) }.joined(separator: ", "), ">", separator: "")
```

</br>

## 더 고민해 보기

백준에서 발견한 다른 분의 풀이.
`while`문을 순회할 때 배열의 범위를 벗어나는 로직을 나머지로 구현함.

```Swift
let line: [Int] = readLine()!.split(separator: " ").map { Int($0)! }
var nums: [Int] = Array<Int>(1...line[0])
var result: [Int] = []
var lastK: Int = line[1] - 1

while true {
    result.append(nums.remove(at: lastK))
    if nums.isEmpty { break }
    lastK = (lastK + line[1] - 1) % nums.count
}

print("<", result.map { String($0) }.joined(separator: ", "), ">", separator: "")
```

```Swift
```
