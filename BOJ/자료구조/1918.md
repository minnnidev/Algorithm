## BOJ 1918 후위 표기식

|🔗|https://www.acmicpc.net/problem/1918|
|---|---|
|풀이 언어|Swift|
|풀이 날짜|23.04.16|

</br>


##  풀이

중위 표기식을 후위 표기식으로 바꾸는 문제 </br>
고려해야 할 것은 사칙연산 순서와 괄호 </br>
연산자의 우선순위를 구할 수 있는 함수를 만든다. 괄호는 우선 순위를 가장 낮게 한다. </br>
결과 배열과 연산자 스택을 선언하고, 입력받은 line을 순회한다. </br>

```
 case (:
    연산자 스택에 push한다.
 case ):
    먼저 계산해야 하므로 연산자 스택에서 (가 나올 때까지 pop한 뒤 (를 제외한 연사자들을 결과 배열에 추가한다.
 case 연산자 스택이 비어 있거나 스택의 top의 우선순위가 현재 연산자의 우선순위보다 낮다면:
    그대로 연산자 스택에 push해 준다.
 그외:
    연산자 스택이 비어 있지 않다면, top의 연산자 우선순위가 현재 연산자의 우선순위가 높을 때, 연신지 스택에서 pop한 뒤 결과 배열에 넣어준다,
    현재 연산자를 연산자 스택에 넣어준다.
```
 입력받은 line을 모두 순회했다면, 연산자 스택에 있던 연산자들은 pop한 뒤 결과 배열에 넣어준다.
 
 </br>

```Swift
let line: String = readLine()!
var result: [Character] = []
var opStack: [Character] = []

func getPriority(op: Character) -> Int {
    switch op {
    case "+", "-":
        return 1
    case "*", "/":
        return 2
    case "(", ")":
        return 0
    default:
        break
    }
    return 0
}

for char in line {
    if char.isLetter { result.append(char) }
    else {
        if char == "(" {
            opStack.append(char)
        } else if char == ")" {
            while(true) {
                let op = opStack.removeLast()
                if op == "(" {
                    break
                }
                result.append(op)
            }
        } else if opStack.isEmpty || getPriority(op: char) > getPriority(op: opStack.last!) {
            opStack.append(char)
        } else {
            while !opStack.isEmpty {
                let top = opStack.last!
                if getPriority(op: top) >= getPriority(op: char) {
                    result.append(opStack.removeLast())
                } else { break }
            }
            opStack.append(char)
        }
    }
}

while !opStack.isEmpty {
    result.append(opStack.removeLast())
}

print(String(result))

```
