//
//  [백준 2457] 공주님.swift
//  Algorithm
//
//  Created by 김민 on 12/14/23.
//
// 백준 2457 공주님의 정원 https://www.acmicpc.net/problem/2457

/*
[풀이]
정원이 넓지 않으므로 정원에 심는 꽃들의 수를 가능한 적게 한다.
-> 가장 오래 피어 있는 꽃을 우선으로 심어야 한다.
3월 1일부터 매일 한 가지 이상의 꽃이 피어 있어야 하므로, 시간순 정렬이 필요하다.
따라서 일찍 피는 순으로 정렬한 뒤, 피는 날짜가 같다면 늦게 지는 순으로 정렬한다.

3월 1일부터 매일 한 가지 이상의 꽃이 피어 있어야 한다.
-> 현재 꽃이 피어 있다고 가정했을 때, 다음 피는 꽃은 현재 꽃이 지기 전이나 지는 날에 피어야 한다.

가장 오래 피어 있는 꽃은 어떻게 찾아야 할까?
-> 현재 꽃이 지기 전이나 지는 날에 피는 꽃들 중에, 지는 날짜가 가장 큰 꽃을 고른다.
endDate라는 변수를 만들어서, 현재 꽃이 지기 전이나 지는 날에 피는 꽃들로 범위를 잡고 순회하며, 지는 날짜의 최댓값을 계속해서 갱신했다.

날짜를 쉽계 비교하기 위해 4자리로 형식을 맞추었다.
ex. 1월 1일 -> 101, 10월 27일 -> 1027
이렇게 형식을 맞춰두면 해당 월이 30일인지, 31인지, 28일인지를 고려하지않아도 된다.
✅ 날짜 포맷을 맞출 생각을 못했었는데, 여러 풀이를 보다가 알게 되었다. 앞으로 자주 써먹어야겠음!!!!!!
*/

let N = Int(readLine()!)!
var dates = Array(repeating: [Int](), count: N)

for i in 0..<N {
    let input = readLine()!.split(separator: " ").map { Int($0)! }
    dates[i].append(input[0] * 100 + input[1])
    dates[i].append(input[2] * 100 + input[3])
}

dates.sort { // 정렬
    if $0[0] == $1[0] {
        return $0[1] > $1[1]
    } else {
        return $0[0] < $1[0]
    }
}

var index = 0
var endDate = 301
var count = 0

while endDate < 1201 { // 꽃은 11월 30일까지만 피어 있으면 된다
    // 꽃이 1개일 때는 고려하지 않는다
    if N == 1 {
        break
    }

    /*
     인덱스가 범위를 넘어가거나, 다음에 필 꽃의 피는 날짜와 현재 핀 꽃의 지는 날짜가 이어지지 않으면 탈출한다.
     피는 날짜순으로 정렬해 두었기 때문에 첫 번째 요소만 고려하면 된다.
    */
    if index == N || dates[0][0] > endDate {
        break
    }

    var tmpEndDate = -1

    for i in index..<N {
        if dates[i][0] <= endDate {
            /*
             endDate보다 피는 날짜가 작은 꽃들 중에서
             가장 오랜 시간 피어 있는 꽃을 찾기 위해서 종료 날짜의 최댓값을 갱신한다
             */
            tmpEndDate = max(tmpEndDate, dates[i][1])
            if i == N - 1 { index += 1 } // 마지막 인덱스일 경우에는 탈출 조건을 만족시켜주기 위해 인덱스에 +1
        } else {
            /*
             for문 순회 중에, 꽃이 피는 날짜가 현재 피어 있는 꽃의 종료 날짜보다 큰 경우는 for문을 탈출하고 index를 i로 갱신시켜,
             다음 순회에서는 해당 인덱스부터 순회를 시작하도록 한다.
             */
            index = i
            break
        }
    }

    endDate = tmpEndDate // endDate를 갱신
    count += 1
}

if N == 1  { // 꽃이 1개일 때 3월 1일 ~ 11월 30일 범위를 만족하면 1을 출력, 아니면 0을 출력한다
    print(dates[0][0] <= 301 && dates[0][1] >= 1201 ? 1 : 0)
} else { // 꽃이 11월 30일까지 피어 있다면 count를 출력하고, 아니면 0을 출력한다
    print(endDate < 1201 ? 0 : count)
}

/*
[느낀점]
n번의 시도 끝에 푼 문제,,, 🥲
원래 시간을 정해두고 최대한 고민을 해 보다가, 안 풀리면 넘어가는데 이 문제는 풀이를 봐도 이해가 안 돼서 계속 도전했다.
반례 모음집에서 반례를 다 넣어가며 풀이를 했던 문제이다.
빠른 입출력을 사용한 풀이도 있고, 아닌 풀이도 있던데 일단 안 쓰고 시간 초과가 안 뜨게 풀어봄.
*/
