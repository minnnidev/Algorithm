//
//  [백준 16963] A -> B.swift
//  Algorithm
//
//  Created by 김민 on 1/24/24.
//
// 백준 16963 A -> B https://www.acmicpc.net/problem/16953

/*
[📌 전략]
A->B로 가는 건 1번, 2번 조건을 사용하는 다양한 루트가 있지만 거꾸로 B->A 순서로 접근하면 루트가 하나밖에 없을 거라 생각하여 B->A순으로 접근
case 1. 현재 수가 짝수라면, 이전 수에서 1번 조건을 사용했을 것
case 2. 현재 수의 1의 자리 수가 1이면, 이전 수에서 2번 조건을 사용했을 것
case 3. 나머지 경우는 이전 수에서 1번 2번 조건 모두 사용하여 만들 수 없는 경우들. 이때는 수를 a로 만들 수 없다.
모든 케이스를 고려하여 b->a로 탐색해가되, 현재 수가 a보다 작아지면 영원히 a를 만들 수 없으므로 -1 출력

[✅ 풀이]
case 1. 2로 나눠 이전 수 찾기
case 2. 10으로 나눠 이전 수 찾기
case 3. 탐색 불가. -1 출력 후 탈출
*/

let line = readLine()!.split(separator: " ").map { Int($0)! }
var (a, b) = (line[0], line[1])
var count = 1

while true {
    if b == a { // a를 만든 경우
        print(count)
        break
    }

    if b < a { // a보다 작아져 a를 만들 수 없는 경우
        print(-1)
        break
    }

    if b % 2 == 0 { // 현재 수가 짝수라면 2를 나눠 이전 수 저장
        b /= 2
    } else if b % 10 == 1 { // 현재 수의 1의 자리가 1이라면 10으로 나눠 이전 수 저장
        b /= 10
    } else { // 그외의 경우는 a를 만들 수 없으므로 탈출
        print(-1)
        break
    }

    count += 1
}

/*
[📝 기록]
사실 그리디 접근보다 먼저 생각난 게 bfs였음
다만 입력이 커서 모든 거리를 측정할 순 없을 거라 생각했다.

[📌 전략]
1번 조건, 2번 조건으로 주변을 탐색했을 때 해당 수가 b보다 작거나 같을 때만 큐에 넣기
방문 배열, 거리 배열 등 대신 현재수 와 연산 횟수에 대한 정보를 함께 큐에 넣기

[✅ 풀이]
1. 큐에 (현재 수, 연산 횟수) 튜플 넣기
    - 따라서 초기값은 (a, 1)
2. 큐에 들어있는 요소들의 모든 탐색이 끝날 때까지 반복
    - 큐에서 요소를 dequeue하여 1번 조건, 2번 조건 수를 탐색
    - 해당 수가 b보다 작거나 같으면 큐에 넣어 다음 탐색을 준비한다
    - 큐에서 dequeue한 요소가 b와 같아지면 연산 횟수를 출력하고 탈출
    - 큐의 요소들에 대한 탐색을 모두 끝냈지만 b에 도달하지 못했다면 -1 출력
*/

//let line = readLine()!.split(separator: " ").map { Int($0)! }
//let (a, b) = (line[0], line[1])
//var q = [(a, 1)]
//var index = 0
//
//func bfs() {
//    while index < q.count {
//        let x = q[index]
//        index += 1
//
//        if x.0 == b {
//            print(x.1)
//            return
//        }
//
//        [x.0*2, x.0*10+1].forEach {
//            if $0 <= b {
//                q.append(($0, x.1+1))
//            }
//        }
//    }
//    print(-1)
//}
//
//bfs()
